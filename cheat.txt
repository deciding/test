ticket-257825-ticket-improve-liu
http://product-ci:8081/nexus/content/repositories/hue-product/
117060827
handlermapping, DTOCacheUtil

cassandra partition key in
autoindex why program level
elasticsearch, UI logic written by ourselves

MasterSearchEntity(textSearchFieldMap=null, baseDateSearchField=, fullTextSearchString=, searchConditions=[MasterSearchConditionsEntity(groupName=Position, groupId=position, params=[MasterSearchConditionsEntity.FacetParam(type=check, value=Developer)], allItemShown=false, open=true), MasterSearchConditionsEntity(groupName=null, groupId=department_id_reference, params=[], allItemShown=false, open=false), MasterSearchConditionsEntity(groupName=null, groupId=disabled, params=[], allItemShown=false, open=false)], pageNumber=0, showAllHistory=false)
MasterSearchConditionsEntity(groupName=Position, groupId=position, params=[MasterSearchConditionsEntity.FacetParam(type=check, value=Developer)], allItemShown=false, open=true)

1. 
List<MasterSearchConditionsEntity> searchConditions=masterSearchEntity.getSearchConditions();
MasterSearchConditionsEntity positionConditionsEntity=searchConditions.get(0);
LinkedHashMap<String, String> positionMap = new LinkedHashMap<>();
positionMap.put("@type", MasterSearchConditionsEntity.INITIAL);
positionMap.put("id", "position");
positionMap.put("value", "Developer");
positionConditionsEntity.setParams(Arrays.asList(new MasterSearchConditionsEntity.FacetParam(
        MasterSearchConditionsEntity.INITIAL, positionMap)));
return masterSearchEntity;

2. 
HashMap<String,Collection<String>> dict=new HashMap<>();
dict.put("docsearch",Arrays.asList("position","pos"));
typeSetting.setGroupDictionary(new com.worksap.company.framework.elasticsearch.basic.docsearch.parser.DocSearchGroupDictionaryImpl(dict));
return typeSetting;
*add boost group *100 boost, + "pos,position" keyword to should

3.
DocSearcherImpl.search use DocSearchTypeSetting.getMapper
by default we use HitDocumentResponseMapper, which use FullTextSearchResultMapper to convert List<FullTextAggregationResponse> to Map<String, List<FacetBucketEntity>>, which use HitDocumentMapper to convert FullTextSearchHit to HitDocument,
Solution: SearchResultEntity

4. FullTextAggregationResponse.getName map to List<FacetBucketEntity> <-
convertBucketsRecursive FullTextSingleBucketAggregationResponse.getAggregations() -> FullTextMultiBucketsAggregationResponse.getBuckets() -> create recursively
but at last we use facet key to get List<FacetBucketEntity> in the map.

5. searchCondition + searchResult -> checkbox output

6. messy params, setPagingParams, setDataParams, setMapper

7. 
typeSetting.setAllowAmbiguity(true);
typeSetting.setDetailedGroupConditions(Arrays.asList(new com.worksap.company.framework.elasticsearch.basic.GroupCondition("docsearch","Developer",com.worksap.company.framework.elasticsearch.request.query.Occur.MUST),new com.worksap.company.framework.elasticsearch.basic.GroupCondition("docsearch","HR",com.worksap.company.framework.elasticsearch.request.query.Occur.MUST)));
return typeSetting;

StringTypeSettingsDefinition.create don't have AUTOCOMPLETE_PARTIAL_MATCH/autoPartMatch/autoPartial

docsearch: prefix query:1.9, correct:19, (for detailed group, we use prefix query)
autocomplete: prefix autoOption:1, correct:10, (autoFuzzy:1)

8.
autocompleteEntity.set
typeSetting.setOptionGroup("autocomplete")

autoOption for all contextwords:0.01

why only one option group?

9. MasterSearchConditionsEntity -> post filter
	Aggregations -> FacetBucketEntity
FilterAggregation, RangeAggregation, DateRangeAggregation, TermAggregation
influenceFilter: for agg, add to all other aggs; for post filter, add the condition

10. status, hierachy, 

11. morelikethis
moreLikeThis:function_score(functions, boost_mode)

12. setType+setPartition, setIdentifier?

13. no phrase match

PathMatchingResourcePatternResolver
private static List<URL> collectTypeLayoutPathes() throws IOException {
    ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(
            TypeLayoutDataGetterImpl.class.getClassLoader());
    String locationPattern = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX
            + "typelayout/**/*.typelayout.json";
    Resource[] resources = resolver.getResources(locationPattern); // yields empty array

    List<URL> result = new ArrayList<URL>();
    for (Resource resource : resources) {
        result.add(resource.getURL());
    }

    return result;
}

public static String toJson(Map<String, Object> data) {
    StringWriter sw = new StringWriter();
    JsonWriter writer = new JsonWriter(sw);
    Gson gson = new Gson();
    writer.setIndent(" ");
    Type type = new TypeToken<Map<String, Object>>() {
    }.getType();
    gson.toJson(data, type, writer);
    return sw.toString();
}


WeightedFieldQueryBuilderFactory(get from typeinfo)(SimpleWeightedFieldQueryBuilderFactory, MLStringFieldQueryBuilderFactory, LocaleFieldQueryBuilderFactory)
create List<WeightedFieldQueryBuilder> from FieldQueryBuilder, Map<String, FieldQueryBuilder> (BindFieldQueryBuilder, WrappedFieldQueryBuilder)
WeightedFieldQueryBuilder.build->new WrappedFieldQuery(FieldQuery contains BindFieldQuery, WrappedFieldQuery, ConstantScoreFieldQuery, ConstantScoreFilteredFieldQuery, WeightedScoreFieldQuery)
-> wrap to ConstantScoreFieldQuery -> put into array
-> AutocompleteRequestBuilder.createOptionedQuery (use org.elasticsearch.index.query.QueryBuilders.boolQuery()-> createBaseQuery -> use FieldQuery.get -> QueryBuilders.constantScoreQuery(QueryBuilder).boost(score) (JsonEchoQueryBuilder)-> org.elasticsearch.client.Client.prepareMultiSearch() return MultiSearchRequestBuilder -> add org.elasticsearch.client.Client.prepareSearch() return SearchRequestBuilder -> MultiSearchRequestBuilder.execute.actionGet